/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
/*
 * Starting address for GPIO D 0x40020C00
 */

uint32_t volatile *const GPIOx_MODER  	= (uint32_t *) (0x40020C00 + 0x00);
uint32_t volatile *const RCC_AHB1ENR 	= (uint32_t *) (0x40023800 + 0x30);
uint32_t volatile *const GPIOx_PUPDR 	= (uint32_t *) (0x40020C00 + 0x0C);
uint32_t volatile *const GPIOx_ODR 		= (uint32_t *) (0x40020C00 + 0x14);
uint32_t volatile *const GPIOx_IDR 		= (uint32_t *) (0x40020C00 + 0x10);


void setAllGpioHigh();
void delay();

int main(void)
{

	// Enable RCC_AHB1ENR Clock
	*RCC_AHB1ENR |= (1<< 3);

	//Set (ROWs) Pins PD0,PD1,PD2,PD3 to output
	*GPIOx_MODER &= ~(0xFF << 0); // clear
	*GPIOx_MODER |= (0x55 << 0);  //set
												/*
													*GPIOx_MODER |= (1 << 0);
													*GPIOx_MODER |= (1 << 2);
													*GPIOx_MODER |= (1 << 4);
													*GPIOx_MODER |= (1 << 6); */
	// Set (COLs) Pins 8,9,10,11 to input
	*GPIOx_MODER &= ~(0xFF << 16);



	// activate internal pull up resistors for COLs
												/*
												   *GPIOx_PUPDR |= (1 << 16);
													*GPIOx_PUPDR |= (1 << 18);
													*GPIOx_PUPDR |= (1 << 20);
													*GPIOx_PUPDR |= (1 << 22); */
		*GPIOx_PUPDR &= ~(0xFF << 16); // clear
		*GPIOx_PUPDR |= (0x55 << 16); // set



	while (1) {
		// Make all row GPIO a high state
		setAllGpioHigh();

		// Make R1 a low state
		*GPIOx_ODR &= ~(1 << 0);

		if (!(*GPIOx_IDR & (1 << 8))) {
			// bit read is 0 or low
			delay();
			printf("1\n");

		}

		if (!(*GPIOx_IDR & (1 << 9))) {
			delay();
			printf("2\n");

		}

		if (!(*GPIOx_IDR & (1 << 10))) {
			delay();
			printf("3\n");

		}

		if (!(*GPIOx_IDR & (1 << 11))) {
			delay();
			printf("A\n");

		}

		// Make R2 a low state
		setAllGpioHigh();
		*GPIOx_ODR &= ~(1<<1);

		if (!(*GPIOx_IDR & (1 << 8))) {
			// bit read is 0 or low
			delay();
			printf("4\n");

		}

		if (!(*GPIOx_IDR & (1 << 9))) {
			delay();
			printf("5\n");

		}

		if (!(*GPIOx_IDR & (1 << 10))) {
			delay();
			printf("6\n");

		}

		if (!(*GPIOx_IDR & (1 << 11))) {
			delay();
			printf("B\n");

		}

		// Make R3 a low state
		setAllGpioHigh();
		*GPIOx_ODR &= ~(1<<2);

		if (!(*GPIOx_IDR & (1 << 8))) {
			// bit read is 0 or low
			delay();
			printf("7\n");

		}

		if (!(*GPIOx_IDR & (1 << 9))) {
			delay();
			printf("8\n");

		}

		if (!(*GPIOx_IDR & (1 << 10))) {
			delay();
			printf("9\n");

		}

		if (!(*GPIOx_IDR & (1 << 11))) {
			delay();
			printf("C\n");

		}

		// Make R4 a low state
		setAllGpioHigh();
		*GPIOx_ODR &= ~(1<<3);


		if (!(*GPIOx_IDR & (1 << 8))) {
			// bit read is 0 or low
			delay();
			printf("*\n");

		}

		if (!(*GPIOx_IDR & (1 << 9))) {
			delay();
			printf("0\n");

		}

		if (!(*GPIOx_IDR & (1 << 10))) {
			delay();
			printf("#\n");

		}

		if (!(*GPIOx_IDR & (1 << 11))) {
			delay();
			printf("D\n");

		}

	}
}

void setAllGpioHigh(){
	/*
	*GPIOx_ODR |= (1<<0);
	*GPIOx_ODR |= (1<<1);
	*GPIOx_ODR |= (1<<2);
	*GPIOx_ODR |= (1<<3); */

	*GPIOx_ODR |= 0x0F;
}

void delay() {
	for (uint32_t i = 0; i < 300000; i++);
}
